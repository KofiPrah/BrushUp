function openVersionComparison(artworkId) { // Create comparison modal const modalHtml = ` `; // Remove existing modal if any const existingModal = document.getElementById('versionComparisonModal'); if (existingModal) { existingModal.remove(); } // Add modal to page document.body.insertAdjacentHTML('beforeend', modalHtml); // Show modal const modal = new bootstrap.Modal(document.getElementById('versionComparisonModal')); modal.show(); // Load version selection options loadVersionSelectors(artworkId); } function loadVersionSelectors(artworkId) { // Get all versions and populate selectors const versions = document.querySelectorAll('.version-thumbnail'); const selector1 = document.getElementById('versionSelect1'); const selector2 = document.getElementById('versionSelect2'); versions.forEach(version => { const versionId = version.getAttribute('data-version'); const imageSrc = version.getAttribute('data-image-url'); const versionLabel = version.querySelector('small').textContent; // Use data attribute for image URL instead of reading src if (imageSrc && imageSrc !== '' && !imageSrc.includes('${') && !imageSrc.includes('%7B')) { const option1 = createVersionOption(versionId, imageSrc, versionLabel, 1); const option2 = createVersionOption(versionId, imageSrc, versionLabel, 2); // Only append if options were created successfully if (option1) selector1.appendChild(option1); if (option2) selector2.appendChild(option2); } else { console.warn('Skipping version with invalid image URL:', versionId, imageSrc); } }); } function createVersionOption(versionId, imageSrc, label, selectorNum) { const option = document.createElement('div'); option.className = 'version-option cursor-pointer p-2 border rounded mb-2'; option.style.cursor = 'pointer'; // Validate image source - only proceed if we have a valid URL if (!imageSrc || imageSrc === '${imageSrc}' || imageSrc.trim() === '' || imageSrc.includes('${') || imageSrc.includes('%7B')) { console.warn('Invalid image source for version:', versionId, 'Source:', imageSrc); return null; } // Create image element safely const imgElement = document.createElement('img'); imgElement.src = imageSrc; imgElement.className = 'img-thumbnail'; imgElement.style.width = '80px'; imgElement.style.height = '80px'; imgElement.style.objectFit = 'cover'; imgElement.onerror = function() { this.style.display = 'none'; }; const labelDiv = document.createElement('div'); labelDiv.className = 'mt-1'; labelDiv.textContent = label; option.appendChild(imgElement); option.appendChild(labelDiv); option.addEventListener('click', function() { // Update preview const preview = document.getElementById(`versionPreview${selectorNum}`); preview.innerHTML = ''; // Clear existing content // Create preview image safely const previewImg = document.createElement('img'); previewImg.src = imageSrc; previewImg.className = 'img-fluid rounded'; previewImg.style.maxHeight = '300px'; previewImg.onerror = function() { this.style.display = 'none'; }; const previewLabel = document.createElement('div'); previewLabel.className = 'mt-2'; const strong = document.createElement('strong'); strong.textContent = label; previewLabel.appendChild(strong); preview.appendChild(previewImg); preview.appendChild(previewLabel); // Update selection state const selector = document.getElementById(`versionSelect${selectorNum}`); selector.querySelectorAll('.version-option').forEach(opt => { opt.classList.remove('border-primary'); }); option.classList.add('border-primary'); }); return option; } // Version Management Functions function deleteVersion(versionId, versionNumber) { // Show confirmation modal const modalHtml = ` `; // Remove existing modal if any const existingModal = document.getElementById('deleteVersionModal'); if (existingModal) { existingModal.remove(); } // Add modal to page document.body.insertAdjacentHTML('beforeend', modalHtml); // Show modal const modal = new bootstrap.Modal(document.getElementById('deleteVersionModal')); modal.show(); } function confirmDeleteVersion(versionId) { // Get CSRF token const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]').value; // Show loading state const deleteBtn = document.querySelector('#deleteVersionModal .btn-danger'); const originalText = deleteBtn.innerHTML; deleteBtn.innerHTML = 'Deleting...'; deleteBtn.disabled = true; // Send delete request fetch(`/api/artworks/versions/${versionId}/delete/`, { method: 'DELETE', credentials: 'same-origin', headers: { 'X-CSRFToken': csrfToken, 'X-Requested-With': 'XMLHttpRequest', 'Content-Type': 'application/json' } }) .then(response => { if (!response.ok) { throw new Error(`HTTP ${response.status}: ${response.statusText}`); } return response.json(); }) .then(data => { // Close modal const modal = bootstrap.Modal.getInstance(document.getElementById('deleteVersionModal')); modal.hide(); // Show success message showToast('Success', 'Version deleted successfully.', 'success'); // Remove the version thumbnail from the page const versionThumbnail = document.querySelector(`[data-version="${versionId}"]`); if (versionThumbnail) { versionThumbnail.remove(); } // Refresh page after a delay setTimeout(() => { window.location.reload(); }, 1500); }) .catch(error => { console.error('Error deleting version:', error); // Reset button deleteBtn.innerHTML = originalText; deleteBtn.disabled = false; // Show error message showToast('Error', 'Failed to delete version. Please try again.', 'danger'); }); } function archiveVersion(versionId, versionNumber) { // Show confirmation modal const modalHtml = ` `; // Remove existing modal if any const existingModal = document.getElementById('archiveVersionModal'); if (existingModal) { existingModal.remove(); } // Add modal to page document.body.insertAdjacentHTML('beforeend', modalHtml); // Show modal const modal = new bootstrap.Modal(document.getElementById('archiveVersionModal')); modal.show(); } function confirmArchiveVersion(versionId) { // Get CSRF token and reason const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]').value; const reason = document.getElementById('archiveReason').value; // Show loading state const archiveBtn = document.querySelector('#archiveVersionModal .btn-warning'); const originalText = archiveBtn.innerHTML; archiveBtn.innerHTML = 'Archiving...'; archiveBtn.disabled = true; // Send archive request fetch(`/api/versions/${versionId}/archive/`, { method: 'POST', credentials: 'same-origin', headers: { 'X-CSRFToken': csrfToken, 'X-Requested-With': 'XMLHttpRequest', 'Content-Type': 'application/json' }, body: JSON.stringify({ reason: reason }) }) .then(response => { if (!response.ok) { throw new Error(`HTTP ${response.status}: ${response.statusText}`); } return response.json(); }) .then(data => { // Close modal const modal = bootstrap.Modal.getInstance(document.getElementById('archiveVersionModal')); modal.hide(); // Show success message showToast('Success', 'Version archived successfully.', 'success'); // Add archived badge to the version thumbnail const versionThumbnail = document.querySelector(`[data-version="${versionId}"]`); if (versionThumbnail) { const archiveBadge = document.createElement('span'); archiveBadge.className = 'position-absolute top-0 start-0 badge bg-secondary'; archiveBadge.innerHTML = 'Archived'; archiveBadge.style.fontSize = '0.6rem'; versionThumbnail.querySelector('.position-relative').appendChild(archiveBadge); // Add opacity to show it's archived versionThumbnail.style.opacity = '0.7'; } // Refresh page after a delay setTimeout(() => { window.location.reload(); }, 1500); }) .catch(error => { console.error('Error archiving version:', error); // Reset button archiveBtn.innerHTML = originalText; archiveBtn.disabled = false; // Show error message showToast('Error', 'Failed to archive version. Please try again.', 'danger'); }); } // Function to unarchive a version function unarchiveVersion(versionId) { // Get CSRF token const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]').value; // Send unarchive request fetch(`/api/versions/${versionId}/unarchive/`, { method: 'POST', credentials: 'same-origin', headers: { 'X-CSRFToken': csrfToken, 'X-Requested-With': 'XMLHttpRequest', 'Content-Type': 'application/json' } }) .then(response => { if (!response.ok) { throw new Error(`HTTP ${response.status}: ${response.statusText}`); } return response.json(); }) .then(data => { // Show success message showToast('Success', 'Version unarchived successfully.', 'success'); // Remove archived badge from the version thumbnail const versionThumbnail = document.querySelector(`[data-version="${versionId}"]`); if (versionThumbnail) { const archiveBadge = versionThumbnail.querySelector('.badge'); if (archiveBadge) { archiveBadge.remove(); } // Remove opacity to show it's no longer archived versionThumbnail.style.opacity = '1'; } // Refresh page after a delay setTimeout(() => { window.location.reload(); }, 1500); }) .catch(error => { console.error('Error unarchiving version:', error); showToast('Error', 'Failed to unarchive version. Please try again.', 'danger'); }); } // Function to switch to a different version function switchToVersion(artworkId, versionId) { // Add visual feedback const thumbnail = document.querySelector(`[data-version="${versionId}"]`); if (thumbnail) { thumbnail.style.opacity = '0.6'; } fetch(`/api/versions/${versionId}/switch/`, { method: 'POST', headers: { 'X-CSRFToken': getCookie('csrftoken'), 'Content-Type': 'application/json', }, credentials: 'same-origin' }) .then(response => response.json()) .then(data => { if (data.version) { // Update the main artwork image const mainImage = document.getElementById('main-artwork-image'); if (mainImage && mainImage.tagName === 'IMG' && (data.version.image_url || data.version.image)) { mainImage.src = data.version.image_url || data.version.image; } // Update version display indicators document.querySelectorAll('.version-thumbnail').forEach(thumb => { thumb.classList.remove('active'); const img = thumb.querySelector('.img-thumbnail'); if (img) { img.classList.remove('border-primary'); } }); // Mark selected version as active const activeThumb = document.querySelector(`[data-version="${versionId}"]`); if (activeThumb) { activeThumb.classList.add('active'); const img = activeThumb.querySelector('.img-thumbnail'); if (img) { img.classList.add('border-primary'); } } // Add version indicator and back button const versionIndicator = document.querySelector('.version-indicator'); if (versionIndicator) { versionIndicator.remove(); } const indicatorHtml = `
Viewing Version ${data.version.version_number} ${data.version.version_notes ? `
${data.version.version_notes}` : ''}
`; const artworkContainer = document.querySelector('.artwork-image').parentElement; artworkContainer.insertAdjacentHTML('afterbegin', indicatorHtml); showToast('Success', `Switched to version ${data.version.version_number}`, 'success'); } if (thumbnail) { thumbnail.style.opacity = '1'; } }) .catch(error => { console.error('Error switching version:', error); showToast('Error', 'Failed to switch version. Please try again.', 'danger'); if (thumbnail) { thumbnail.style.opacity = '1'; } }); } function backToCurrent() { // Remove version indicator const versionIndicator = document.querySelector('.version-indicator'); if (versionIndicator) { versionIndicator.remove(); } // Reset to current version const currentThumbnail = document.querySelector('[data-version="current"]'); if (currentThumbnail) { const currentImage = currentThumbnail.querySelector('img'); if (currentImage) { const mainImage = document.querySelector('.artwork-image img'); if (mainImage) { mainImage.src = currentImage.src; } } // Update active states document.querySelectorAll('.version-thumbnail').forEach(thumb => { thumb.classList.remove('active'); const img = thumb.querySelector('.img-thumbnail'); if (img) { img.classList.remove('border-primary'); } }); currentThumbnail.classList.add('active'); const currentImg = currentThumbnail.querySelector('.img-thumbnail'); if (currentImg) { currentImg.classList.add('border-primary'); } } showToast('Success', 'Returned to current version', 'success'); } // Toast notification function function showToast(title, message, type = 'info') { const toastHtml = ` `; // Create toast container if it doesn't exist let toastContainer = document.getElementById('toast-container'); if (!toastContainer) { toastContainer = document.createElement('div'); toastContainer.id = 'toast-container'; toastContainer.className = 'toast-container position-fixed top-0 end-0 p-3'; toastContainer.style.zIndex = '9999'; document.body.appendChild(toastContainer); } // Add toast to container toastContainer.insertAdjacentHTML('beforeend', toastHtml); // Show the toast const toastElement = toastContainer.lastElementChild; const toast = new bootstrap.Toast(toastElement, { delay: 3000 }); toast.show(); // Remove toast element after it's hidden toastElement.addEventListener('hidden.bs.toast', () => { toastElement.remove(); }); } // Helper function to get a cookie by name function getCookie(name) { let cookieValue = null; if (document.cookie && document.cookie !== '') { const cookies = document.cookie.split(';'); for (let i = 0; i < cookies.length; i++) { const cookie = cookies[i].trim(); // Does this cookie string begin with the name we want? if (cookie.substring(0, name.length + 1) === (name + '=')) { cookieValue = decodeURIComponent(cookie.substring(name.length + 1)); break; } } } return cookieValue; } // Reaction AJAX handling document.addEventListener('DOMContentLoaded', function() { console.log('DOM loaded - initializing reaction buttons'); // Get all reaction buttons with reaction-btn class const reactionButtons = document.querySelectorAll('.reaction-btn'); console.log(`Found ${reactionButtons.length} reaction buttons`); reactionButtons.forEach(button => { button.addEventListener('click', function(e) { e.preventDefault(); // Add visual feedback that the button was clicked this.classList.add('active'); setTimeout(() => this.classList.remove('active'), 200); const critiqueId = this.getAttribute('data-reaction-critique-id'); const reactionType = this.getAttribute('data-reaction-type'); console.log(`Toggling reaction: ${reactionType} for critique: ${critiqueId}`); // Get CSRF token - try different methods to ensure we get it let csrfToken = document.querySelector('[name=csrfmiddlewaretoken]')?.value; if (!csrfToken) { csrfToken = getCookie('csrftoken'); console.log('Using cookie for CSRF token'); } // Send AJAX request to the correct URL // The correct endpoint is /critiques/{id}/react/ajax/ const apiUrl = `/critiques/${critiqueId}/react/ajax/`; console.log(`Sending reaction to: ${apiUrl}`); // Debug what's being submitted console.log(`CSRF Token: ${csrfToken}`); // Add a direct form submission approach as a fallback // This ensures the buttons work even if fetch fails const formData = new FormData(); formData.append('reaction_type', reactionType); formData.append('csrfmiddlewaretoken', csrfToken); fetch(apiUrl, { method: 'POST', credentials: 'same-origin', headers: { 'X-Requested-With': 'XMLHttpRequest', 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken }, body: JSON.stringify({ 'reaction_type': reactionType }) }) .then(response => { console.log('Response status:', response.status); if (!response.ok) { return response.text().then(text => { console.error('Error response:', text); throw new Error(`Error: ${response.status} - ${text}`); }); } return response.json(); }) .then(data => { console.log('Response data:', data); if (data.error) { showToast('Error', data.error, 'danger'); return; } // Update button appearance based on toggle state if (data.toggled) { // If reaction was added, update to filled button this.classList.remove('btn-outline-success', 'btn-outline-primary', 'btn-outline-info'); if (reactionType === 'HELPFUL') { this.classList.add('btn-success'); } else if (reactionType === 'INSPIRING') { this.classList.add('btn-primary'); } else if (reactionType === 'DETAILED') { this.classList.add('btn-info'); } } else { // If reaction was removed, update to outline button this.classList.remove('btn-success', 'btn-primary', 'btn-info'); if (reactionType === 'HELPFUL') { this.classList.add('btn-outline-success'); } else if (reactionType === 'INSPIRING') { this.classList.add('btn-outline-primary'); } else if (reactionType === 'DETAILED') { this.classList.add('btn-outline-info'); } } // Show success toast notification showToast('Success', data.message, 'success'); // Update count badges updateReactionCount(critiqueId, 'helpful', data.helpful_count); updateReactionCount(critiqueId, 'inspiring', data.inspiring_count); updateReactionCount(critiqueId, 'detailed', data.detailed_count); // Show success message showToast('Success', data.message, 'success'); }) .catch(error => { console.error('Error:', error); showToast('Error', 'There was an error processing your reaction. Please try again.', 'danger'); }); }); }); // Helper function to update reaction count badge function updateReactionCount(critiqueId, type, count) { // Find the button for this critique and reaction type const button = document.querySelector(`[data-reaction-critique-id="${critiqueId}"][data-reaction-type="${type.toUpperCase()}"]`); if (button) { // Find the count badge inside this button const countBadge = button.querySelector(`.${type}-count`); if (countBadge) { countBadge.textContent = count; } } } // Helper function to show toast notifications function showToast(title, message, type = 'info') { const toastContainer = document.createElement('div'); toastContainer.style.position = 'fixed'; toastContainer.style.bottom = '20px'; toastContainer.style.right = '20px'; toastContainer.style.zIndex = '1050'; const toast = document.createElement('div'); toast.className = `toast bg-${type} text-white`; toast.setAttribute('role', 'alert'); toast.setAttribute('aria-live', 'assertive'); toast.setAttribute('aria-atomic', 'true'); toast.innerHTML = `
${title}

${message}
`; toastContainer.appendChild(toast); document.body.appendChild(toastContainer); // Initialize and show the toast using Bootstrap const bsToast = new bootstrap.Toast(toast, { delay: 3000 }); bsToast.show(); // Remove the toast element after it's hidden toast.addEventListener('hidden.bs.toast', function () { document.body.removeChild(toastContainer); }); } // Helper function to get CSRF token from cookie function getCookie(name) { let cookieValue = null; if (document.cookie && document.cookie !== '') { const cookies = document.cookie.split(';'); for (let i = 0; i < cookies.length; i++) { const cookie = cookies[i].trim(); if (cookie.substring(0, name.length + 1) === (name + '=')) { cookieValue = decodeURIComponent(cookie.substring(name.length + 1)); break; } } } return cookieValue; } });