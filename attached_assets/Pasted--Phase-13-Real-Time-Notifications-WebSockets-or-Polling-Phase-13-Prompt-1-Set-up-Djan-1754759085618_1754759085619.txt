## Phase 13: Real-Time Notifications (WebSockets or Polling)

- **Phase 13, Prompt 1:** _Set up Django Channels._ Install **django-channels** and update the Django project to support WebSocket connections. Add `channels` to INSTALLED_APPS and set the `ASGI_APPLICATION` in settings (pointing to `artcritique.asgi.application`). Configure a channel layer (for development, use the in-memory channel layer or Redis in production). Provide the installation and settings changes, and create an `asgi.py` if not already present (with `ProtocolTypeRouter` including `websocket` protocol).
    
- **Phase 13, Prompt 2:** _Notification consumer._ Create a Channels **Consumer** (for example, `NotificationConsumer`) that handles WebSocket connections for notifications. When a user connects (perhaps to a path like `/ws/notifications/`), add them to a group specific to their user ID (e.g., group name f"user_{id}"). On receiving a notification (from the signals in Phase 8), use the channel layer to send a message to that user’s group. Implement the consumer such that on connect it accepts and perhaps authenticates the user (you can use channels authentication to get the user from the session or a token). Provide the code for this consumer (it can just send a JSON message for each notification with the notification content or a simple counter).
    
- **Phase 13, Prompt 3:** _Trigger real-time notifications on events._ Update the notification creation logic (from Phase 8 signals) to also send a WebSocket event. For example, in the signal where a Notification object is created, after saving it, send a message via `channel_layer.group_send` to the corresponding user’s channel group. The message can include the notification ID and message (or you could send the whole serialized notification). Provide the updated signal handler code with channel layer usage. (Note: This requires the consumer and channel layer from Prompt 1 and 2 to be set up.)
    
- **Phase 13, Prompt 4:** _Frontend integration for live notifications._ In the React app, connect to the WebSocket to receive notifications in real-time. Use the browser WebSocket API or a library. For example, upon user login, create a WebSocket connection to `ws://<backend-domain>/ws/notifications/` (ensure the path matches the routing in Django Channels). Handle incoming messages: when a notification message is received, update the state holding notifications (e.g., append to a notification list or increment an unread count). Provide code for a React hook or component (like `useNotifications` or a NotificationBell component) that establishes the WebSocket connection and reacts to new messages (perhaps showing a toast or highlighting the notifications icon). Also include cleanup on component unmount (closing the socket). If WebSocket is not available or for simplicity, mention a fallback to polling (e.g., periodically calling GET /api/notifications/ to check for new items).
    
- **Phase 13, Prompt 5:** _Test notification flow._ (Optional) Describe a quick test scenario: User A comments on User B’s artwork. User B (logged in on another client) should immediately receive a WebSocket notification about the new critique. Likewise, if User C marks User A’s critique as helpful, User A should get a notification in real-time. Ensure the system behaves as expected. (No new code, just verifying the integrated functionality.)